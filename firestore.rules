rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // ===== RATE LIMITING FUNCTION =====
    function isRateLimited(collection, userId, maxWrites) {
      let recentWrites = getAfter(/databases/$(database)/documents/rate_limits/$(collection + '_' + userId)).data.count;
      return recentWrites <= maxWrites;
    }
    
    // ===== USERS COLLECTION =====
    match /users/{userId} {
      // ✅ Allow reading own user data only
      allow read: if request.auth != null && request.auth.uid == userId;
      
      // ✅ Allow writing own user data with validation
      allow write: if request.auth != null && 
        request.auth.uid == userId &&
        // Validate required fields
        request.resource.data.keys().hasAll(['created_at']) &&
        // Prevent modification of critical fields
        request.resource.data.user_id == userId;
      
      // ✅ Allow reading/writing push tokens for authenticated users only
      match /pushTokens/{tokenId} {
        allow read, write: if request.auth != null && 
          request.auth.uid == userId &&
          // Validate token format
          request.resource.data.token.matches('^[A-Za-z0-9:_-]+$');
      }
    }
    
    // ===== EVENTS COLLECTION =====
    match /events/{eventId} {
      // ✅ Everyone can view active events only, but authenticated users can view all events
      allow read: if 
        (request.time < resource.data.expires_at && resource.data.is_active == true) ||
        (request.auth != null);
      
      // ✅ Only authenticated users can create/modify events
      allow create: if request.auth != null && 
        // Validate required fields
        request.resource.data.keys().hasAll(['name', 'expires_at', 'is_active', 'created_at']) &&
        // Event must expire in the future
        request.resource.data.expires_at > request.time &&
        // Event name validation
        request.resource.data.name.size() > 0 &&
        request.resource.data.name.size() <= 100;
      
      // ✅ Only authenticated users can update events
      allow update: if request.auth != null && 
        // Cannot change critical fields
        request.resource.data.event_id == resource.data.event_id &&
        request.resource.data.created_at == resource.data.created_at;
      
      // ✅ Only authenticated users can delete events
      allow delete: if request.auth != null;
    }
    
    // ===== EVENT PROFILES COLLECTION =====
    match /event_profiles/{profileId} {
      // ✅ Allow reading profiles only for active events and before expiration
      allow read: if 
        exists(/databases/$(database)/documents/events/$(resource.data.event_id)) &&
        request.time < resource.data.expires_at &&
        request.time < get(/databases/$(database)/documents/events/$(resource.data.event_id)).data.expires_at &&
        get(/databases/$(database)/documents/events/$(resource.data.event_id)).data.is_active == true;
      
      // ✅ Allow creating profiles with strict validation and rate limiting
      allow create: if 
        // Event must exist and be active
        exists(/databases/$(database)/documents/events/$(request.resource.data.event_id)) &&
        request.time < get(/databases/$(database)/documents/events/$(request.resource.data.event_id)).data.expires_at &&
        get(/databases/$(database)/documents/events/$(request.resource.data.event_id)).data.is_active == true &&
        // Rate limiting: max 5 profiles per session per hour
        isRateLimited('profiles', request.resource.data.session_id, 5) &&
        // Profile must have required fields
        request.resource.data.keys().hasAll(['event_id', 'session_id', 'first_name', 'age', 'gender_identity', 'profile_color', 'expires_at', 'created_at']) &&
        // Age must be valid
        request.resource.data.age is int &&
        request.resource.data.age >= 18 &&
        request.resource.data.age <= 100 &&
        // Profile color must be valid hex
        request.resource.data.profile_color.matches('^#[0-9A-Fa-f]{6}$') &&
        // Session ID must be a valid UUID format
        request.resource.data.session_id.matches('^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$') &&
        // First name validation
        request.resource.data.first_name.size() > 0 &&
        request.resource.data.first_name.size() <= 50 &&
        // Gender identity validation
        request.resource.data.gender_identity in ['male', 'female', 'non-binary', 'other'] &&
        // Expiration must match event expiration
        request.resource.data.expires_at == get(/databases/$(database)/documents/events/$(request.resource.data.event_id)).data.expires_at &&
        // Created timestamp must be current
        request.resource.data.created_at == request.time &&
        // Default visibility should be true for new profiles
        request.resource.data.is_visible == true;
      
      // ✅ Allow updating only own profile with restrictions
      allow update: if 
        // Can only update own profile (session-based auth)
        resource.data.session_id == request.resource.data.session_id &&
        // Event must still be active
        request.time < resource.data.expires_at &&
        request.time < get(/databases/$(database)/documents/events/$(resource.data.event_id)).data.expires_at &&
        get(/databases/$(database)/documents/events/$(resource.data.event_id)).data.is_active == true &&
        // Cannot change critical fields
        request.resource.data.event_id == resource.data.event_id &&
        request.resource.data.session_id == resource.data.session_id &&
        request.resource.data.created_at == resource.data.created_at &&
        request.resource.data.expires_at == resource.data.expires_at &&
        // Validate updated fields
        request.resource.data.first_name.size() > 0 &&
        request.resource.data.first_name.size() <= 50 &&
        request.resource.data.age is int &&
        request.resource.data.age >= 18 &&
        request.resource.data.age <= 100;
      
      // ✅ Allow deleting only own profile
      allow delete: if 
        // Can only delete own profile (session-based auth)
        resource.data.session_id == request.resource.data.session_id;
    }
    
    // ===== LIKES COLLECTION =====
    match /likes/{likeId} {
      // ✅ Allow reading likes only for active events
      allow read: if 
        exists(/databases/$(database)/documents/events/$(resource.data.event_id)) &&
        request.time < get(/databases/$(database)/documents/events/$(resource.data.event_id)).data.expires_at &&
        get(/databases/$(database)/documents/events/$(resource.data.event_id)).data.is_active == true;
      
      // ✅ Allow creating likes with validation and rate limiting
      allow create: if 
        // Event must be active
        exists(/databases/$(database)/documents/events/$(request.resource.data.event_id)) &&
        request.time < get(/databases/$(database)/documents/events/$(request.resource.data.event_id)).data.expires_at &&
        get(/databases/$(database)/documents/events/$(request.resource.data.event_id)).data.is_active == true &&
        // Rate limiting: max 20 likes per session per hour
        isRateLimited('likes', request.resource.data.liker_session_id, 20) &&
        // Both profiles must exist and be active
        exists(/databases/$(database)/documents/event_profiles/$(request.resource.data.from_profile_id)) &&
        exists(/databases/$(database)/documents/event_profiles/$(request.resource.data.to_profile_id)) &&
        // Both profiles must be visible
        get(/databases/$(database)/documents/event_profiles/$(request.resource.data.from_profile_id)).data.is_visible == true &&
        get(/databases/$(database)/documents/event_profiles/$(request.resource.data.to_profile_id)).data.is_visible == true &&
        // Cannot like own profile
        request.resource.data.from_profile_id != request.resource.data.to_profile_id &&
        // Required fields
        request.resource.data.keys().hasAll(['event_id', 'from_profile_id', 'to_profile_id', 'liker_session_id', 'liked_session_id', 'created_at']) &&
        // Created timestamp must be current
        request.resource.data.created_at == request.time;
      
      // ✅ Allow updating likes (for mutual match status) with visibility check
      allow update: if 
        // Can only update own likes (session-based auth)
        resource.data.from_profile_id == request.resource.data.from_profile_id &&
        // Event must still be active
        request.time < get(/databases/$(database)/documents/events/$(resource.data.event_id)).data.expires_at &&
        get(/databases/$(database)/documents/events/$(resource.data.event_id)).data.is_active == true &&
        // Both profiles must still be visible
        exists(/databases/$(database)/documents/event_profiles/$(resource.data.from_profile_id)) &&
        exists(/databases/$(database)/documents/event_profiles/$(resource.data.to_profile_id)) &&
        get(/databases/$(database)/documents/event_profiles/$(resource.data.from_profile_id)).data.is_visible == true &&
        get(/databases/$(database)/documents/event_profiles/$(resource.data.to_profile_id)).data.is_visible == true &&
        // Cannot change critical fields
        request.resource.data.event_id == resource.data.event_id &&
        request.resource.data.from_profile_id == resource.data.from_profile_id &&
        request.resource.data.to_profile_id == resource.data.to_profile_id &&
        request.resource.data.created_at == resource.data.created_at;
      
      // ✅ Allow deleting own likes
      allow delete: if 
        // Can only delete own likes (session-based auth)
        resource.data.from_profile_id == request.resource.data.from_profile_id;
    }
    
    // ===== MESSAGES COLLECTION =====
    match /messages/{messageId} {
      // ✅ Allow reading messages only if user is participant and event is active
      allow read: if 
        exists(/databases/$(database)/documents/events/$(resource.data.event_id)) &&
        request.time < get(/databases/$(database)/documents/events/$(resource.data.event_id)).data.expires_at &&
        get(/databases/$(database)/documents/events/$(resource.data.event_id)).data.is_active == true &&
        // User must be participant
        (resource.data.from_profile_id == request.resource.data.session_id || 
         resource.data.to_profile_id == request.resource.data.session_id);
      
      // ✅ Allow creating messages with validation and rate limiting
      allow create: if 
        // Event must be active
        exists(/databases/$(database)/documents/events/$(request.resource.data.event_id)) &&
        request.time < get(/databases/$(database)/documents/events/$(request.resource.data.event_id)).data.expires_at &&
        get(/databases/$(database)/documents/events/$(request.resource.data.event_id)).data.is_active == true &&
        // Rate limiting: max 50 messages per session per hour
        isRateLimited('messages', request.resource.data.from_profile_id, 50) &&
        // Sender must be the profile creating the message (session-based auth)
        request.resource.data.from_profile_id == request.resource.data.from_profile_id &&
        // Both profiles must exist and be visible
        exists(/databases/$(database)/documents/event_profiles/$(request.resource.data.from_profile_id)) &&
        exists(/databases/$(database)/documents/event_profiles/$(request.resource.data.to_profile_id)) &&
        get(/databases/$(database)/documents/event_profiles/$(request.resource.data.from_profile_id)).data.is_visible == true &&
        get(/databases/$(database)/documents/event_profiles/$(request.resource.data.to_profile_id)).data.is_visible == true &&
        // Cannot message self
        request.resource.data.from_profile_id != request.resource.data.to_profile_id &&
        // Required fields
        request.resource.data.keys().hasAll(['event_id', 'from_profile_id', 'to_profile_id', 'content', 'created_at']) &&
        // Content validation
        request.resource.data.content.size() > 0 &&
        request.resource.data.content.size() <= 1000 &&
        // Content must not contain malicious patterns
        !request.resource.data.content.matches('.*<script.*>.*</script>.*') &&
        !request.resource.data.content.matches('.*javascript:.*') &&
        // Created timestamp must be current
        request.resource.data.created_at == request.time;
      
      // ✅ Allow updating only own messages (for editing)
      allow update: if 
        // Can only update own messages (session-based auth)
        resource.data.from_profile_id == request.resource.data.from_profile_id &&
        // Event must still be active
        request.time < get(/databases/$(database)/documents/events/$(resource.data.event_id)).data.expires_at &&
        get(/databases/$(database)/documents/events/$(resource.data.event_id)).data.is_active == true &&
        // Both profiles must still exist and be visible
        exists(/databases/$(database)/documents/event_profiles/$(resource.data.from_profile_id)) &&
        exists(/databases/$(database)/documents/event_profiles/$(resource.data.to_profile_id)) &&
        get(/databases/$(database)/documents/event_profiles/$(resource.data.from_profile_id)).data.is_visible == true &&
        get(/databases/$(database)/documents/event_profiles/$(resource.data.to_profile_id)).data.is_visible == true &&
        // Cannot change critical fields
        request.resource.data.event_id == resource.data.event_id &&
        request.resource.data.from_profile_id == resource.data.from_profile_id &&
        request.resource.data.to_profile_id == resource.data.to_profile_id &&
        request.resource.data.created_at == resource.data.created_at &&
        // Content validation
        request.resource.data.content.size() > 0 &&
        request.resource.data.content.size() <= 1000 &&
        // Content must not contain malicious patterns
        !request.resource.data.content.matches('.*<script.*>.*</script>.*') &&
        !request.resource.data.content.matches('.*javascript:.*');
      
      // ✅ Allow deleting own messages
      allow delete: if 
        // Can only delete own messages (session-based auth)
        resource.data.from_profile_id == request.resource.data.from_profile_id;
    }
    
    // ===== CONTACT SHARES COLLECTION =====
    match /contact_shares/{shareId} {
      // ✅ Allow reading contact shares only if user is participant and event is active
      allow read: if 
        exists(/databases/$(database)/documents/events/$(resource.data.event_id)) &&
        request.time < get(/databases/$(database)/documents/events/$(resource.data.event_id)).data.expires_at &&
        get(/databases/$(database)/documents/events/$(resource.data.event_id)).data.is_active == true &&
        // User must be participant
        (resource.data.from_profile_id == request.resource.data.session_id || 
         resource.data.to_profile_id == request.resource.data.session_id);
      
      // ✅ Allow creating contact shares with validation and rate limiting
      allow create: if 
        // Event must be active
        exists(/databases/$(database)/documents/events/$(request.resource.data.event_id)) &&
        request.time < get(/databases/$(database)/documents/events/$(request.resource.data.event_id)).data.expires_at &&
        get(/databases/$(database)/documents/events/$(request.resource.data.event_id)).data.is_active == true &&
        // Rate limiting: max 10 contact shares per session per hour
        isRateLimited('contact_shares', request.resource.data.from_profile_id, 10) &&
        // Sender must be the profile creating the share (session-based auth)
        request.resource.data.from_profile_id == request.resource.data.from_profile_id &&
        // Both profiles must exist and be visible
        exists(/databases/$(database)/documents/event_profiles/$(request.resource.data.from_profile_id)) &&
        exists(/databases/$(database)/documents/event_profiles/$(request.resource.data.to_profile_id)) &&
        get(/databases/$(database)/documents/event_profiles/$(request.resource.data.from_profile_id)).data.is_visible == true &&
        get(/databases/$(database)/documents/event_profiles/$(request.resource.data.to_profile_id)).data.is_visible == true &&
        // Cannot share with self
        request.resource.data.from_profile_id != request.resource.data.to_profile_id &&
        // Required fields
        request.resource.data.keys().hasAll(['event_id', 'from_profile_id', 'to_profile_id', 'contact_info', 'created_at']) &&
        // Contact info validation
        request.resource.data.contact_info.size() > 0 &&
        request.resource.data.contact_info.size() <= 500 &&
        // Contact info must not contain malicious patterns
        !request.resource.data.contact_info.matches('.*<script.*>.*</script>.*') &&
        !request.resource.data.contact_info.matches('.*javascript:.*') &&
        // Created timestamp must be current
        request.resource.data.created_at == request.time;
      
      // ✅ Allow updating only own contact shares
      allow update: if 
        // Can only update own contact shares (session-based auth)
        resource.data.from_profile_id == request.resource.data.from_profile_id &&
        // Event must still be active
        request.time < get(/databases/$(database)/documents/events/$(resource.data.event_id)).data.expires_at &&
        get(/databases/$(database)/documents/events/$(resource.data.event_id)).data.is_active == true &&
        // Both profiles must still exist and be visible
        exists(/databases/$(database)/documents/event_profiles/$(resource.data.from_profile_id)) &&
        exists(/databases/$(database)/documents/event_profiles/$(resource.data.to_profile_id)) &&
        get(/databases/$(database)/documents/event_profiles/$(resource.data.from_profile_id)).data.is_visible == true &&
        get(/databases/$(database)/documents/event_profiles/$(resource.data.to_profile_id)).data.is_visible == true &&
        // Cannot change critical fields
        request.resource.data.event_id == resource.data.event_id &&
        request.resource.data.from_profile_id == resource.data.from_profile_id &&
        request.resource.data.to_profile_id == resource.data.to_profile_id &&
        request.resource.data.created_at == resource.data.created_at &&
        // Contact info validation
        request.resource.data.contact_info.size() > 0 &&
        request.resource.data.contact_info.size() <= 500 &&
        // Contact info must not contain malicious patterns
        !request.resource.data.contact_info.matches('.*<script.*>.*</script>.*') &&
        !request.resource.data.contact_info.matches('.*javascript:.*');
      
      // ✅ Allow deleting own contact shares
      allow delete: if 
        // Can only delete own contact shares (session-based auth)
        resource.data.from_profile_id == request.resource.data.from_profile_id;
    }
    
    // ===== EVENT FEEDBACK COLLECTION =====
    match /event_feedback/{feedbackId} {
      // ✅ Allow reading feedback only by admins
      allow read: if request.auth != null && request.auth.token.admin == true;
      
      // ✅ Allow creating anonymous feedback with validation and rate limiting
      allow create: if 
        // Event must exist and be active
        exists(/databases/$(database)/documents/events/$(request.resource.data.event_id)) &&
        get(/databases/$(database)/documents/events/$(request.resource.data.event_id)).data.is_active == true &&
        // Rate limiting: max 3 feedback per IP per hour (implemented at app level)
        // Required fields
        request.resource.data.keys().hasAll(['event_id', 'rating', 'feedback_text', 'created_at']) &&
        // Rating must be valid
        request.resource.data.rating is int &&
        request.resource.data.rating >= 1 &&
        request.resource.data.rating <= 5 &&
        // Feedback text validation
        request.resource.data.feedback_text.size() > 0 &&
        request.resource.data.feedback_text.size() <= 1000 &&
        // Feedback must not contain malicious patterns
        !request.resource.data.feedback_text.matches('.*<script.*>.*</script>.*') &&
        !request.resource.data.feedback_text.matches('.*javascript:.*') &&
        // Created timestamp must be current
        request.resource.data.created_at == request.time;
      
      // ✅ No updates allowed (feedback is immutable)
      allow update: if false;
      
      // ✅ Only admins can delete feedback
      allow delete: if request.auth != null && request.auth.token.admin == true;
    }
    
    // ===== ANALYTICS COLLECTION =====
    // Write-only collection for backend analytics
    match /analytics/{eventId}/{docId} {
      // ✅ No direct reads (analytics data is sensitive)
      allow read: if false;
      
      // ✅ Only Cloud Functions/admin can write analytics
      allow write: if request.auth != null && request.auth.token.admin == true;
    }
    

    
    // ===== RATE LIMITING COLLECTION =====
    match /rate_limits/{limitId} {
      // ✅ Only authenticated users can manage rate limits
      allow read, write: if request.auth != null;
    }
    
    // ===== USER SAVED PROFILES COLLECTION =====
    // Locally saved profile data for future use
    match /user_saved_profiles/{profileId} {
      // ✅ Allow reading only own saved profiles
      allow read: if request.auth != null && request.auth.uid == resource.data.user_id;
      
      // ✅ Allow creating saved profiles with validation
      allow create: if 
        request.auth != null &&
        request.auth.uid == request.resource.data.user_id &&
        // Required fields
        request.resource.data.keys().hasAll(['user_id', 'profile_data', 'created_at']) &&
        // Profile data validation
        request.resource.data.profile_data.size() > 0 &&
        request.resource.data.profile_data.size() <= 10000 &&
        // Created timestamp must be current
        request.resource.data.created_at == request.time;
      
      // ✅ Allow updating own saved profiles
      allow update: if 
        request.auth != null &&
        request.auth.uid == resource.data.user_id &&
        // Cannot change user_id
        request.resource.data.user_id == resource.data.user_id &&
        request.resource.data.created_at == resource.data.created_at;
      
      // ✅ Allow deleting own saved profiles
      allow delete: if request.auth != null && request.auth.uid == resource.data.user_id;
    }
    
    // ===== DEFAULT RULE =====
    // Deny all other operations by default
    match /{document=**} {
      allow read, write: if false;
    }
  }
} 